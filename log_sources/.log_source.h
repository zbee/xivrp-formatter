// XIVRP-Formatter Copyright (C) 2024 Ethan Henderson <ethan@zbee.codes>
// Licensed under GPLv3 - Refer to the LICENSE file for the complete text

#ifndef XIVRP_FORMATTER_LOG_SOURCE_H
#define XIVRP_FORMATTER_LOG_SOURCE_H

#include "../messages/messages.h"
#include "../settings/settings.h"
#include <chrono>
#include <list>
#include <map>
#include <string>

namespace log_source {

/**
 * Sources of log files
 * @see settings::log_type
 * @see settings::structure::settings_guide
 * @see settings::structure::log_file_type
 */
enum class source {
  /**
   * @brief For when no source was capable of handling the log file
   */
  no_supported_source = 0,
  // Skipping here to align with the settings::log_type enum
  chatscan = 2,
  discord = 3,
  chat2 = 4,
  gobchat = 5,
  xivlogger = 6,
};

/**
 * @brief Class to handle log files, determining their source and parsing them.
 * Effectively, this is just a wrapper for classes that inherit from
 * log_source::Ilog_source
 */
class log_source {
public:
  /**
   * @brief Constructor for log files essentially; handles determining the
   * source of a log or finding the log files automatically to pick between, and
   * aliasing a the appropriate parser for the log
   * @param log_find_type The parser to use for the log file, or to us smart
   * find
   * @param log The path to the log file, if type is not smart
   * @return The source of the log file
   * @see settings::structure::settings_guide
   * @see settings::log_type
   */
  log_source(settings::log_type log_find_type, std::string log = "");

  /**
   * @brief The given log file path, if any
   */
  std::string log_file_path;

  /**
   * @brief The source of the log file, always matching it
   * @see log_source::determine_source()
   * @see log_source::source
   * @see settings::log_type
   */
  source source;

  /**
   * @brief Determine which source can handle a given log file
   * @see settings::structure::settings_guide
   * @see settings::structure::log_file_type
   */
  enum source determine_source();

  /**
   * @brief Find the most recent log files of every source, picking the most
   * recent from any, for the user to pick from if there's not an obvious
   * answer
   * @return A chosen log file path
   * @see log_source::Ilog_source::find_logs_of_this_source()
   */
  std::string find_logs();

  /**
   * @brief Parse messages from the found log file using the log file's source
   * @return A messages::structure object of the parsed log file
   */
  messages::structure parse_messages();
};

/**
 * @brief Interface for log sources
 */
class Ilog_source {
public:
  /**
   * @brief The source of the log file
   * @see settings::structure::settings_guide
   * @see settings::structure::log_file_type
   */
  log_source source;

  /**
   * @brief Method to check a given log is parseable by this source, i.e. to
   * intelligently find the source of a user-provided log file, and to validate
   * the log file
   * @param log The log file path
   * @return Whether the log file is parseable by this source
   * @see settings::loader::verify_log_file()
   */
  virtual bool log_is_this_source(std::string log) = 0;

  /**
   * @brief Method to find log files that are generated by this source
   * @return A map of log file paths and their last modified time, for selecting
   * the most recent logs
   */
  virtual std::map<std::string, std::chrono::system_clock::time_point>
  find_logs_of_this_source() = 0;

  /**
   * @brief Method to parse messages from a given log log
   * @param log The path to the log log, likely from the map returned by
   * ILog_source::find_logs_of_this_source or from the
   * settings::structure::log_file_path
   * @return A messages::structure object
   * @see messages::structure::log_file_path
   */
  virtual messages::structure parse_messages(std::string log) = 0;
};

} // namespace log_source

#endif // XIVRP_FORMATTER_LOG_SOURCE_H
